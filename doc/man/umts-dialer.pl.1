.\" Automatically generated by Pod::Man v1.37, Pod::Parser v1.32
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sh \" Subsection heading
.br
.if t .Sp
.ne 5
.PP
\fB\\$1\fR
.PP
..
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.Sh), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.if \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.\"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.hy 0
.if n .na
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "UMTS-DIALER 1"
.TH UMTS-DIALER 1 "2006-07-21" "perl v5.8.8" "User Contributed Perl Documentation"
.SH "NAME"
umts\-dialer.pl \- A GSM/UMTS mass dialing tool
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
\&\fBumts\-dialer.pl\fR [options] <number>
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
A recurrent task in terminal testing is to produce Key Performance
Indicators (\s-1KPI\s0), that is to say measurements of how well the
terminal performs. This is usually achieved through drive tests,
which means making a large number of calls to an answering machine
from one or more terminals placed in vehicle and measuring the number
of call setup failures and call drops.
.PP
The \fBumts\-dialer.pl\fR script provides a means of performing such
drive tests in an automatic fashion as it is capable of mass call
dialing, detecting call setup success or failure, monitoring call
drops and producing the statistics of the run.
.SH "CALL MONITORING MECHANICS"
.IX Header "CALL MONITORING MECHANICS"
A call can be broken down into the following steps:
.IP "\fBdial call\fR" 4
.IX Item "dial call"
Issue the ATDxxxx; to dial an number and examine the reply of the
\&\s-1ATD\s0 command, \s-1OK\s0 means success, anything else is a call setup failure.
.IP "\fBcheck call setup\fR" 4
.IX Item "check call setup"
The terminal is periodically polled by looking either at the list of
current calls (\s-1AT+CLCC\s0) or the phone activity status (\s-1AT+CPAS\s0) until
it finishes dialing and alerting. The possible outcomes are either we
have an active call, in which case we have a successful call setup,
or we have no active calls in which case we have a call setup
failure.
.IP "\fBmonitor call\fR" 4
.IX Item "monitor call"
The terminal is periodically polled by looking either at the list of
current calls (\s-1AT+CLCC\s0) or the phone activity status (\s-1AT+CPAS\s0) for a
specified call duration and we check we still have an active call. If
this is not the case, we have a dropped call and we sleep until the
end of the expected call time.
.IP "\fBhangup call\fR" 4
.IX Item "hangup call"
Issue the \s-1ATH\s0 command to hangup the terminal.
.SH "OPTIONS"
.IX Header "OPTIONS"
.Vb 6
\& Common options:
\&  \-d          debugging mode
\&  \-h          display this help message
\&  \-p<port>    terminal is connected to serial port <port>
\&              e.g. '\e\e.\eCOM12', '/dev/usb/acm/0'
\&  \-z          use dummy terminal
.Ve
.PP
.Vb 7
\& Options:
\&  \-c<calls>   make <calls> calls (default : 1000)
\&  \-l<prefix   write log to <prefix>_log.txt and
\&              write results to <prefix>_results.txt
\&  \-t<time>    make <time> second calls (default: 120s)
\&  \-v          make video calls
\&  \-w<wait>    wait for <wait> seconds between calls (default: 60s)
.Ve
